use crate::{
  api::{
    block_dims::BlockDims,
    data_type::LiteralDataValue,
  },
  model::{
    AssignStmtModel,
    BufferBindingModel,
    CodeBlockModel,
    CmpOpExprModel,
    EntryPointModel,
    ExprStmtModel,
    ExpressionModel,
    IfElseStmtModel,
    ReturnStmtModel,
    ShaderModel,
    StatementModel,
    VarDeclStmtModel,
  },
  printer::GeneratorBuffer
};

/**
 * Generate the WebGPU Shading Language (WGSL) code for the given AST.
 */
pub(crate) fn generate_wgsl(model: &ShaderModel) -> String {
  const LONG_COMMENT_BAR: &'static str =
    "////////////////////////////////////////////////////////////////////////";

  let mut gen = GeneratorBuffer::new();

  // Write out codegen header.
  gen.write_line(
    &format!("/// !!! Generated by blacklight (v{}) !!!", env!("CARGO_PKG_VERSION"))
  );
  gen.newline();
  gen.newline();

  // Write out buffer bindings.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Buffer bindings.");
  gen.newline();
  for buffer_binding in model.buffer_bindings() {
    gen_buffer_binding(&mut gen, buffer_binding);
    gen.newline();
  }

  // Write out entrypoints.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Entrypoints.");
  gen.newline();
  for entrypoint in model.entrypoints() {
    gen_entrypoint(&mut gen, entrypoint);
    gen.newline();
  }

  gen.to_string()
}

fn gen_buffer_binding(gen: &mut GeneratorBuffer, buffer_binding: &BufferBindingModel) {
  let group = buffer_binding.group();
  let index = buffer_binding.index();
  let disposition = buffer_binding.disposition();
  gen.write_line(format!("@group({}) @binding({})", group, index));
  gen.write_line(format!("var<storage, {}> {}: array<{}>;",
    disposition.as_str(),
    buffer_binding.name(),
    buffer_binding.data_type().as_str(),
  ));
}

fn gen_entrypoint(gen: &mut GeneratorBuffer, entrypoint: &EntryPointModel) {
  gen.write_line("@compute");
  gen.write_line(format!("@workgroup_size{}",
    match entrypoint.block_dims() {
      BlockDims::OneD(x) => format!("({})", x),
      BlockDims::TwoD([x, y]) => format!("({}, {})", x, y),
      BlockDims::ThreeD([x, y, z]) => format!("({}, {}, {})", x, y, z),
    }
  ));
  gen.write_line(format!("fn {}(", entrypoint.name()));
  gen.with_indent(|gen| {
    gen.write_line("@builtin(global_invocation_id)");
    gen.write_line("bl_global_id: vec3<u32>");
  });
  gen.write_line(") {");
  gen.with_indent(|gen| {
    gen_code_block(gen, entrypoint.code_block());
  });
  gen.write_line("}");
}

fn gen_code_block(gen: &mut GeneratorBuffer, code_block: &CodeBlockModel) {
  for stmt in code_block.statements() {
    gen_statement(gen, stmt);
  }
}

fn gen_statement(gen: &mut GeneratorBuffer, stmt: &StatementModel) {
  match stmt {
    StatementModel::VarDecl(var_decl) => {
      gen_var_decl(gen, var_decl);
    },
    StatementModel::Assign(assign_stmt) => {
      gen_assign_stmt(gen, assign_stmt);
    },
    StatementModel::IfElse(if_else_stmt) => {
      gen_if_else_stmt(gen, if_else_stmt);
    },
    StatementModel::Expr(expr_stmt) => {
      gen_expr_stmt(gen, expr_stmt);
    },
    StatementModel::Return(return_stmt) => {
      gen_return_stmt(gen, return_stmt);
    },
  }
}

fn gen_var_decl(gen: &mut GeneratorBuffer, var_decl: &VarDeclStmtModel) {
  gen.write_start(format!("var {}: {} = ", var_decl.name(), "TYPE"));
  gen_expression(gen, var_decl.expression());
  gen.write_end(";");
}

fn gen_assign_stmt(gen: &mut GeneratorBuffer, assign_stmt: &AssignStmtModel) {
  gen.write_start(format!("{} = ", assign_stmt.name()));
  gen_expression(gen, assign_stmt.expression());
  gen.write_end(";");
}

fn gen_if_else_stmt(gen: &mut GeneratorBuffer, if_else_stmt: &IfElseStmtModel) {
  gen.write_start("if (");
  gen_expression(gen, if_else_stmt.condition());
  gen.write_end(") {");
  gen.with_indent(|gen| {
    gen_code_block(gen, if_else_stmt.if_block());
  });
  if let Some(else_block) = if_else_stmt.else_block() {
    gen.write_line("} else {");
    gen.with_indent(|gen| {
      gen_code_block(gen, else_block);
    });
  }
  gen.write_line("}");
}

fn gen_expr_stmt(gen: &mut GeneratorBuffer, expr_stmt: &ExprStmtModel) {
  gen.write_start("");
  gen_expression(gen, expr_stmt.expression());
  gen.write_end(";");
}

fn gen_return_stmt(gen: &mut GeneratorBuffer, return_stmt: &ReturnStmtModel) {
  gen.write_start("return");
  if let Some(expr) = return_stmt.expression() {
    gen.write(" ");
    gen_expression(gen, expr);
  }
  gen.write_end(";");
}

fn gen_expression(gen: &mut GeneratorBuffer, expr: &ExpressionModel) {
  match expr {
    ExpressionModel::Identifier(ident_expr) => {
      gen.write(ident_expr.name());
    },
    ExpressionModel::Literal(literal_expr) => {
      gen_literal_data_value(gen, literal_expr.value());
    },
    ExpressionModel::CmpOp(cmp_op_expr) => {
      gen_cmp_op_expr(gen, cmp_op_expr);
    },
  }
}

fn gen_literal_data_value(gen: &mut GeneratorBuffer, literal_data_value: &LiteralDataValue) {
  match literal_data_value {
    LiteralDataValue::Bool(b) => {
      gen.write(if *b { "true" } else { "false" });
    },
    LiteralDataValue::I32(int32) => {
      gen.write(int32.to_string());
    },
    LiteralDataValue::Vec2I32([x, y]) => {
      gen.write(format!("vec2<i32>({}, {})", x, y));
    },
    LiteralDataValue::Vec3I32([x, y, z]) => {
      gen.write(format!("vec3<i32>({}, {}, {})", x, y, z));
    },
    LiteralDataValue::Vec4I32([x, y, z, w]) => {
      gen.write(format!("vec4<i32>({}, {}, {}, {})", x, y, z, w));
    },
    LiteralDataValue::U32(uint32) => {
      gen.write(uint32.to_string());
    },
    LiteralDataValue::Vec2U32([x, y]) => {
      gen.write(format!("vec2<u32>({}, {})", x, y));
    },
    LiteralDataValue::Vec3U32([x, y, z]) => {
      gen.write(format!("vec3<u32>({}, {}, {})", x, y, z));
    },
    LiteralDataValue::Vec4U32([x, y, z, w]) => {
      gen.write(format!("vec4<u32>({}, {}, {}, {})", x, y, z, w));
    },
    LiteralDataValue::F32(float32) => {
      gen.write(float32.to_string());
    },
    LiteralDataValue::Vec2F32([x, y]) => {
      gen.write(format!("vec2<f32>({}, {})", x, y));
    },
    LiteralDataValue::Vec3F32([x, y, z]) => {
      gen.write(format!("vec3<f32>({}, {}, {})", x, y, z));
    },
    LiteralDataValue::Vec4F32([x, y, z, w]) => {
      gen.write(format!("vec4<f32>({}, {}, {}, {})", x, y, z, w));
    },
  }
}

fn gen_cmp_op_expr(gen: &mut GeneratorBuffer, cmp_op_expr: &CmpOpExprModel) {
  let operator_str = cmp_op_expr.op().operator_str();
  gen.write("(");
  gen_expression(gen, cmp_op_expr.lhs());
  gen.write(format!(" {} ", operator_str));
  gen_expression(gen, cmp_op_expr.rhs());
  gen.write(")");
}
