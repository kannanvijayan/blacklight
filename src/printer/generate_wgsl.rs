use crate::{
  api::{
    block_dims::BlockDims,
    data_type::{ DataTypeRepr, LiteralDataValue, StructDataTypeRepr },
    buffer_attributes::{ BufferDispositionRepr, BufferMemorySpaceRepr },
  },
  model::{
    AssignStmtModel,
    BufferBindingModel,
    CodeBlockModel,
    CmpOpExprModel,
    EntryPointModel,
    ExprStmtModel,
    ExpressionModel,
    IdentifierModel,
    IfElseStmtModel,
    LvalueModel,
    ReturnStmtModel,
    ShaderModel,
    StatementModel,
    VarDeclStmtModel,
    FunctionModel,
    VariableBindingModel,
  },
  printer::GeneratorBuffer
};

/**
 * Generate the WebGPU Shading Language (WGSL) code for the given AST.
 */
pub(crate) fn generate_wgsl(model: &ShaderModel) -> String {
  const LONG_COMMENT_BAR: &'static str =
    "////////////////////////////////////////////////////////////////////////";

  let mut gen = GeneratorBuffer::new();

  // Write out codegen header.
  gen.write_line(
    &format!("/// !!! Generated by blacklight (v{}) !!!", env!("CARGO_PKG_VERSION"))
  );
  gen.newline();
  gen.newline();

  // Write out type bindings.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Type bindings.");
  gen.newline();
  for struct_data_type in model.struct_data_types() {
    gen_struct_data_type(&mut gen, struct_data_type);
    gen.newline();
  }

  // Write out uniforms type and buffer.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Uniforms.");
  gen.newline();
  let mut full_uniform_structs = model.full_uniform_structs();
  for uniform_struct in &full_uniform_structs {
    gen_struct_data_type(&mut gen, uniform_struct);
  }
  let uniform_struct = full_uniform_structs.pop().unwrap();
  let uniform_buffer_binding =
    BufferBindingModel::new(
      IdentifierModel::new("uniforms"),
      BufferMemorySpaceRepr::Uniform,
      BufferDispositionRepr::Read,
      0,
      0,
      DataTypeRepr::Struct(uniform_struct),
      /* is_singleton */ true,
    );
  gen_buffer_binding(&mut gen, &uniform_buffer_binding);
  gen.newline();

  // Write out buffer bindings.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Buffer bindings.");
  gen.newline();
  for buffer_binding in model.buffer_bindings() {
    gen_buffer_binding(&mut gen, buffer_binding);
    gen.newline();
  }

  // Write out constant definitions.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Constant definitions.");
  gen.newline();
  for const_def in model.const_definitions() {
    gen_variable_binding(&mut gen, const_def);
  }
  gen.newline();

  // Write out function definitions.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Function definitions.");
  gen.newline();
  for function in model.functions() {
    gen_function_binding(&mut gen, function);
    gen.newline();
  }

  // Write out entrypoints.
  gen.write_line(LONG_COMMENT_BAR);
  gen.write_line("/// Entrypoints.");
  gen.newline();
  for entrypoint in model.entrypoints() {
    gen_entrypoint(&mut gen, entrypoint);
    gen.newline();
  }

  gen.to_string()
}

fn gen_struct_data_type(gen: &mut GeneratorBuffer, struct_data_type: &StructDataTypeRepr) {
  gen.write_line(format!("struct {} {{", struct_data_type.name().as_str()));
  gen.with_indent(|gen| {
    for field in struct_data_type.fields() {
      gen.write_line(format!("{}: {},",
        field.name(),
        field.data_type().wgsl_source(),
      ));
    }
  });
  gen.write_line("}");
}

fn gen_buffer_binding(gen: &mut GeneratorBuffer, buffer_binding: &BufferBindingModel) {
  let group = buffer_binding.group();
  let index = buffer_binding.index();
  let memory_space = buffer_binding.memory_space();
  let disposition = buffer_binding.disposition();
  gen.write_line(format!("@group({}) @binding({})", group, index));

  let type_string = buffer_binding.data_type().wgsl_source();
  let type_string = if buffer_binding.is_singleton() {
    type_string.to_string()
  } else {
    format!("array<{}>", type_string)
  };
  gen.write_line(format!("var<{}, {}> {}: {};",
    memory_space.as_str(),
    disposition.as_str(),
    buffer_binding.name().as_str(),
    type_string,
  ));
}

fn gen_variable_binding(gen: &mut GeneratorBuffer, variable_binding: &VariableBindingModel) {
  let initial_value = variable_binding.initial_value();
  let name_str = variable_binding.name().as_str();
  let disp_str = variable_binding.disposition().wgsl_source();
  let data_type_str = variable_binding.data_type().wgsl_source();
  gen.write_start(format!("{} {}: {}", disp_str, name_str, data_type_str));
  if let Some(initial_value) = initial_value {
    gen.write(" = ");
    gen_expression(gen, initial_value);
  }
  gen.write_line(";");
}

fn gen_function_binding(gen: &mut GeneratorBuffer, function: &FunctionModel) {
  gen.write_line(format!("fn {}(", function.name().as_str()));
  gen.with_indent(|gen| {
    for (i, arg_name) in function.arg_names().iter().enumerate() {
      gen.write_line(format!("{}: {},",
        arg_name.as_str(),
        function.arg_data_types()[i].wgsl_source(),
      ));
    }
  });
  gen.write_start(")");
  if let Some(return_data_type) = function.return_data_type() {
    gen.write(format!(" -> {}", return_data_type.wgsl_source()));
  }
  gen.write_end(" {");
  gen.with_indent(|gen| {
    gen_code_block(gen, function.code_block());
  });
  gen.write_line("}");
}

fn gen_entrypoint(gen: &mut GeneratorBuffer, entrypoint: &EntryPointModel) {
  gen.write_line("@compute");
  gen.write_line(format!("@workgroup_size{}",
    match entrypoint.block_dims() {
      BlockDims::OneD(x) => format!("({})", x),
      BlockDims::TwoD([x, y]) => format!("({}, {})", x, y),
      BlockDims::ThreeD([x, y, z]) => format!("({}, {}, {})", x, y, z),
    }
  ));
  gen.write_line(format!("fn {}(", entrypoint.name()));
  gen.with_indent(|gen| {
    gen.write_line("@builtin(global_invocation_id)");
    gen.write_line("bl_global_id: vec3<u32>");
  });
  gen.write_line(") {");
  gen.with_indent(|gen| {
    gen_code_block(gen, entrypoint.code_block());
  });
  gen.write_line("}");
}

fn gen_code_block(gen: &mut GeneratorBuffer, code_block: &CodeBlockModel) {
  for stmt in code_block.statements() {
    gen_statement(gen, stmt);
  }
}

fn gen_statement(gen: &mut GeneratorBuffer, stmt: &StatementModel) {
  match stmt {
    StatementModel::VarDecl(var_decl) => {
      gen_var_decl(gen, var_decl);
    },
    StatementModel::Assign(assign_stmt) => {
      gen_assign_stmt(gen, assign_stmt);
    },
    StatementModel::IfElse(if_else_stmt) => {
      gen_if_else_stmt(gen, if_else_stmt);
    },
    StatementModel::Expr(expr_stmt) => {
      gen_expr_stmt(gen, expr_stmt);
    },
    StatementModel::Return(return_stmt) => {
      gen_return_stmt(gen, return_stmt);
    },
  }
}

fn gen_var_decl(gen: &mut GeneratorBuffer, var_decl: &VarDeclStmtModel) {
  gen_variable_binding(gen, var_decl.binding());
}

fn gen_assign_stmt(gen: &mut GeneratorBuffer, assign_stmt: &AssignStmtModel) {
  gen.write_start("");
  gen_lvalue_expr(gen, assign_stmt.target());
  gen.write(" = ");
  gen_expression(gen, assign_stmt.expression());
  gen.write_end(";");
}

fn gen_lvalue_expr(gen: &mut GeneratorBuffer, lvalue: &LvalueModel) {
  match lvalue {
    LvalueModel::Variable(var_name, _) => {
      gen.write(var_name.as_str());
    },
    LvalueModel::BufferElement(buffer_name, index_expr, _) => {
      gen.write(format!("{}[", buffer_name.as_str()));
      gen_expression(gen, index_expr);
      gen.write("]");
    },
    LvalueModel::StructField(struct_expr, field_name, _) => {
      gen_expression(gen, struct_expr);
      gen.write(format!(".{}", field_name.as_str()));
    }
  }
}

fn gen_if_else_stmt(gen: &mut GeneratorBuffer, if_else_stmt: &IfElseStmtModel) {
  gen.write_start("if (");
  gen_expression(gen, if_else_stmt.condition());
  gen.write_end(") {");
  gen.with_indent(|gen| {
    gen_code_block(gen, if_else_stmt.if_block());
  });
  if let Some(else_block) = if_else_stmt.else_block() {
    gen.write_line("} else {");
    gen.with_indent(|gen| {
      gen_code_block(gen, else_block);
    });
  }
  gen.write_line("}");
}

fn gen_expr_stmt(gen: &mut GeneratorBuffer, expr_stmt: &ExprStmtModel) {
  gen.write_start("");
  gen_expression(gen, expr_stmt.expression());
  gen.write_end(";");
}

fn gen_return_stmt(gen: &mut GeneratorBuffer, return_stmt: &ReturnStmtModel) {
  gen.write_start("return");
  if let Some(expr) = return_stmt.expression() {
    gen.write(" ");
    gen_expression(gen, expr);
  }
  gen.write_end(";");
}

fn gen_expression(gen: &mut GeneratorBuffer, expr: &ExpressionModel) {
  match expr {
    ExpressionModel::Identifier(ident_expr) => {
      gen.write(ident_expr.identifier().as_str());
    },
    ExpressionModel::Literal(literal_expr) => {
      gen_literal_data_value(gen, literal_expr.value());
    },
    ExpressionModel::CmpOp(cmp_op_expr) => {
      gen_cmp_op_expr(gen, cmp_op_expr);
    },
    ExpressionModel::BinOp(bin_op_expr) => {
      gen.write("(");
      gen_expression(gen, bin_op_expr.lhs());
      gen.write(format!(" {} ", bin_op_expr.op().operator_str()));
      gen_expression(gen, bin_op_expr.rhs());
      gen.write(")");
    },
    ExpressionModel::BufferRead(buffer_read_expr) => {
      gen.write(buffer_read_expr.buffer_name().as_str());
      gen.write("[");
      gen_expression(gen, buffer_read_expr.index());
      gen.write("]");
    },
    ExpressionModel::StructFieldRead(struct_field_read) => {
      gen_expression(gen, struct_field_read.struct_expr());
      gen.write(".");
      gen.write(struct_field_read.field_name().as_str());
    },
    ExpressionModel::FunctionCall(fucntion_call) => {
      gen.write(fucntion_call.function_name().as_str());
      gen.write("(");
      let arguments = fucntion_call.arguments();
      let argcount = arguments.len();
      for (i, arg_expr) in arguments.iter().enumerate() {
        gen_expression(gen, arg_expr.as_ref());
        if i < argcount - 1 {
          gen.write(", ");
        }
      }
      gen.write(")");
    },
  }
}

fn gen_literal_data_value(gen: &mut GeneratorBuffer, literal_data_value: &LiteralDataValue) {
  gen.write(literal_data_value.wgsl_source());
}

fn gen_cmp_op_expr(gen: &mut GeneratorBuffer, cmp_op_expr: &CmpOpExprModel) {
  let operator_str = cmp_op_expr.op().operator_str();
  gen.write("(");
  gen_expression(gen, cmp_op_expr.lhs());
  gen.write(format!(" {} ", operator_str));
  gen_expression(gen, cmp_op_expr.rhs());
  gen.write(")");
}
